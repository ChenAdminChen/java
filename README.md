# java-demo
 1.serilizable 学习 (BookTest.java,IOTest.java)

    序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。 

    序列化:序列化是将对象转换为容易传输的格式的过程。例如，可以序列化一个对象，然后使用 HTTP 通过 Internet 在客户端和服务器之间传输该对象。在另一端，反序列化将从该流重新构造对象。
    是对象永久化的一种机制。确切的说应该是对象的序列化，一般程序在运行时，产生对象，这些对象随着程序的停止运行而消失，但如果我们想把某些对象（因为是对象，所以有各自不同的特性）保存下来，在程序终止运行后，这些对象仍然存在，可以在程序再次运行时读取这些对象的值，或者在其他程序中利用这些保存下来的对象。这种情况下就要用到对象的序列化。
　　 
    只有序列化的对象才可以存储在存储设备上。为了对象的序列化而需要继承的接口也只是一个象征性的接口而已，也就是说继承这个接口说明这个对象可以被序列化了，没有其他的目的。之所以需要对象序列化，是因为有时候对象需要在网络上传输，传输的时候需要这种序列化处理，从服务器硬盘上把序列化的对象取出，然后通过网络传到客户端，再由客户端把序列化的对象读入内存，执行相应的处理。
　　    
    对象序列化是java的一个特征，通过该特征可以将对象写作一组字节码，当在其他位置读到这些字节码时，可以依此创建一个新的对象，而且新对象的状态与原对象完全相同。为了实现对象序列化，要求必须能够访问类的私有变量，从而保证对象状态能够正确的得以保存和恢复。相应的，对象序列化API能够在对象重建时，将这些值还原给私有的数据成员。这是对java语言访问权限的挑战。通常用在服务器客户端的对象交换上面，另外就是在本机的存储。
    
    对象序列化的最主要的用处就是在传递,和保存对象(object)的时候,保证对象的完整性和可传递性。譬如通过网络传输,或者把一个对象保存成一个文件的时候,要实现序列化接口
    
   private static final long serialVersionUID = 1L;
   序列版本号，一个唯一标识号， 若未指定，则会根据该类的名称及实现的接口及公有变量和私有变量的自动生成一个唯一标识号，但若该类中的属性改变，反序列化则会失败。若类内的内容改变后，需要保证原来的内容，能反序列化，同时保证新产生的序列化能被原来的类反序列化，因此带来的许多测试工作。
   
   运用条件：
      （1）若一个类需要添加到一个框架中去，该框架依赖序列化来实现对象传输或者持久化时，这个类就有必要实现serializable。
      （2）若一个类成为另一个类的组件时，并且后者必须实现Serializable接口时，则组件类必须实现serializable.
   
   实现了Serializabel的类：
      （1）Throwable类：在RMI异常时可以从服务器端传到客户端。
      （2）Component类：GUI可以被发送、保存和恢复。
      （3）HttpServlet类：会话状态（session state)可以被缓存
